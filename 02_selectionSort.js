/**
 * Вспомогательная функция для определения наименьшего элемента в массиве, сложность алгоритма O(n).
 * Суть: проходим по массиву и сравниваем текущее значение с сохраненным в качестве наименьшего,
 * если текущее значение меньше, то сохраняем его в роли наименьшего и идем дальше.
 * @param {Array} arr - массив из чисел;
 * @returns возвращает индекс наименьшего элемента массива;
 */
const findSmallest = (arr) => {
	let smallest = arr[0];
	let indexOfSmallest = 0;

	for (let i = 0; i < arr.length; i++) {
		if (arr[i] < smallest) {
			smallest = arr[i];
			indexOfSmallest = i;
		}
	}
	return indexOfSmallest;
};


/**
 * Реализация алгоритма сортировки выбором, сложность алгоритма O(n^2).
 * Суть: с помощью вспомогательной функции определяем наименьший элемент переданного массива и
 * записываем его в конец нового массива, удалив из исходного. Затем повторяем.
 * @param {Array} arr - обязательно ОТСОРТИРОВАННЫЙ массив по возрастанию;
 * @returns возвращает новый массив из элементов переданного, отстортированных по возрастанию;
 */
const selectionSort = (arr) => {
	const newArr = [];

	for (let i = 0; i < arr.length; i++) {
		let indexOfSmallest = findSmallest(arr);

		newArr.push(...arr.splice(indexOfSmallest, 1));

		// так как длинна массива после splice изменилась, нам надо компенсировать это шагом назад
		i--;
	}

	return newArr;
};