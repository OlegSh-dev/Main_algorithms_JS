/**
 * Реализация алгоритма быстрой сортировки массива, сложность алгоритма O(n * log n)
 * (в худшем случае, когда опорным элементом выбирается всегда первый, а массив уже отсортирован - O(n^2)).
 * Суть: выбираем индекс опорного элемента массива, который максимально близок к его центру, затем сортируем
 * оставшиеся элементы относительно опорного элемента и распределяем их по вспомогательным массивам.
 * Далее рекурсивно вызываем функцию до тех пор, пока не останутся массивы с 0 или 1 элементом, и соединяем
 * эти массивы в итоговый.
 * @param {Array} arr - массив из чисел;
 * @returns отсортированный по возрастанию массив;
 */
const quickSort = (arr) => {

	// базовый сценарий для выхода из рекурсии
	if (arr.length < 2) {
		return arr;
	}

	// рекурсивный сценарий
	let pivot = Math.floor(arr.length / 2);

	const lessArr = [];
	const biggerArr = [];

	for (let i = 0; i < arr.length; i++) {

		// пропускаем опорный элемент
		if (i === pivot) {
			continue;
		}

		if (arr[i] <= arr[pivot]) {
			lessArr.push(arr[i]);
		} else {
			biggerArr.push(arr[i]);
		}
	}

	return quickSort(lessArr).concat(arr[pivot], quickSort(biggerArr));
}
